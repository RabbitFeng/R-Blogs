## [理解Android P内部API的限制调用机制](https://gityuan.com/2019/01/26/hidden_api/)



Google从Android P开始限制对内部API的使用，继续使用则抛出如下异常

![hidden-api-exp](https://raw.githubusercontent.com/RabbitFeng/TyporaPic/master/images/hidden-api-exp-20260107142913315.png)

**限制场景**

ShouldBlockAccessToMember是限制内部API访问的核心路径

- kReflection反射过程：
  - Class_newInstance：对象实例化
  - Class_getDeclaredConstructorInternal：构造方法
  - Class_getDeclaredMethodInternal：获取方法
  - Class_getDeclaredField：获取字段
  - Class_getPublicFieldRecursive：获取字段
- kJNI的JNI调用过程：
  - FindMethodID：查找方法
  - FindFieldID：查找字段
- kLinking动态链接：
  - UnstartedClassNewInstance
  - UnstartedClassGetDeclaredConstructor
  - UnstartedClassGetDeclaredMethod
  - UnstartedClassGetDeclaredField

```
@FastNative
private native Method getDeclaredMethodInternal(String name, Class<?>[] args);

static jobject Class_getDeclaredMethodInternal(JNIEnv* env, jobject javaThis,
                                               jstring name, jobjectArray args) {
  ScopedFastNativeObjectAccess soa(env);
  StackHandleScope<1> hs(soa.Self());
  DCHECK_EQ(Runtime::Current()->GetClassLinker()->GetImagePointerSize(), kRuntimePointerSize);
  DCHECK(!Runtime::Current()->IsActiveTransaction());
  Handle<mirror::Method> result = hs.NewHandle(
      mirror::Class::GetDeclaredMethodInternal<kRuntimePointerSize, false>(
          soa.Self(),
          DecodeClass(soa, javaThis),
          soa.Decode<mirror::String>(name),
          soa.Decode<mirror::ObjectArray<mirror::Class>>(args)));
  //检测该方法是否允许访问【小节2.4】
  if (result == nullptr || ShouldBlockAccessToMember(result->GetArtMethod(), soa.Self())) {
    return nullptr;
  }
  return soa.AddLocalReference<jobject>(result.Get());
}

template<typename T>
ALWAYS_INLINE static bool ShouldBlockAccessToMember(T* member, Thread* self)
    REQUIRES_SHARED(Locks::mutator_lock_) {
  //【小节2.5】
  hiddenapi::Action action = hiddenapi::GetMemberAction(
      member, self, IsCallerTrusted, hiddenapi::kReflection);
  //对于不是允许级别的接口，则通知相应监听器
  if (action != hiddenapi::kAllow) {
    hiddenapi::NotifyHiddenApiListener(member);
  }
  return action == hiddenapi::kDeny;
}
```



