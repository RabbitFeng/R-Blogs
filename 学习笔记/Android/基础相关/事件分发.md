



| class        | 创建时机                                                     |      |      |
| ------------ | ------------------------------------------------------------ | ---- | ---- |
| PhoneWindow  | Activity创建；通过Intrumatention.newActivity()反射创建后，调用Activity.attach()创建 |      |      |
| DecorView    | Activity创建；在PhoneWindow中，setContentView()时延迟创建    |      |      |
| ViewRootImpl | Activity Resume; WindowManagerGlobal.addView()中被赋值；通过setView()将DecorView挂载 |      |      |
|              |                                                              |      |      |

`Activity` -> `PhoneWindow` -> `DecorView` <-> `ViewRootImpl`

**创建时机/位置**

> - `ActivityThread.handleLaunchActivity() `
> - `ActivityThread.performLaunchActivity()`
>   - `Instrumentation.newActivity()**`【Activity创建】**
>   - `activity.attach()` 【PhoneWindow创建】
>     - Activity.onCreate()
>     - Activity.setContentView()
>       - PhoneWindow.setContentView()
>       - PhoneWindow.installDecor()【DecorView创建】
> - `ActivityThread.handleResumeActivity() ` 【DecorView -> Activity】
>   - activity.makeVisible()
>     - wm.addView(mDecor, getWindow().getAttributes()); 【】
>       - WindowGlobal.addView() 【ViewRootImpl创建】
>         - ViewRootImpl.setView(view)【DecorView挂载到ViewRootImpl】
>           - view.assignParent()【构建父子关系】

**关系**

- **Activity -> PhoneWindow**

  - `Activity`在`ActivityThread`实例化后会调用`attach`初始化``PhoneWindow`

- PhoneWindow -> DecorView

  - `Activity.setContentView()`时延迟实例化

    > Activity中findViewById()为什么要在setContentView之后用的原因：
    >
    > `findViewById() -> getWindow().findViewById() -> getDecorView.findViewById()` 。DecorView是在Activity.setContent时在PhoneWindow中延迟实例化。 

# 事件分发起点 `ViewRootImpl` 

1. **System Server (WMS)** -> **InputChannel**
2. **ViewRootImpl** (`WindowInputEventReceiver.onInputEvent`)
3. **InputStage Chain** -> **ViewPostImeInputStage**
4. **DecorView** (`dispatchPointerEvent`)
5. **Activity** (`dispatchTouchEvent`)
6. **ViewGroup / View** (`dispatchTouchEvent` -> `onIntercept` -> `onTouchEvent`) 

> - WindowInputEventReceiver.onInputEvent(InputEvent event)
>
> - enqueueInputEvent(..) // 参数processImmediately始终为true，这里一定会走doProcessInputEvents分支
>
>   - doProcessInputEvents // 遍历队列 将事件递送
>
>     - deliverInputEvent() // 处理完后移除MSG_PROCESS_INPUT_EVENTS
>       - inputStage.deliver(q) 选择合适的InputStage分发 
>
>   - scheduleProcessInputEvents // handler发送 MSG_PROCESS_INPUT_EVENTS; 延迟执行doProcessInputEvents
>



**ViewRootImpl** 并不是直接从硬件驱动拿事件，而是通过一个基于 **Unix Domain Socket** 的跨进程通信管道（**InputChannel**）从系统进程获取。

## 1. 接收&初步分发

当 Activity 启动，`WindowManagerService` (WMS) 为应用创建窗口时，会同时创建一对 **InputChannel**（本质是一对双工的 `socketpair`）： 

- **Server 端**：留在系统进程（InputDispatcher）。
- **Client 端**：通过 Binder 传递给应用进程，并封装在 **ViewRootImpl** 中。 

- **入口点：** 事件通过 `InputChannel` 到达应用进程，由 `ViewRootImpl` 内部的 `WindowInputEventReceiver` 接收。
- **方法：** 触发 `onInputEvent` 方法，随后调用 `enqueueInputEvent` 将事件放入队列。 

## 2. 接收核心：WindowInputEventReceiver

核心职能：

在 ViewRootImpl 内部，有一个名为 `WindowInputEventReceiver` 的内部类，它继承自 `InputEventReceiver`： 

1. **JNI 监听**：该类在 Native 层通过 `NativeInputEventReceiver` 监控 Client 端的 socket 状态。
2. **数据读取**：当底层有触摸事件到来时，Native 层会触发回调，通过 JNI 调用 Java 层的 `dispatchInputEvent` 方法。
3. **放入队列**：`onInputEvent` 被触发后，事件被放入 ViewRootImpl 的待处理队列中
   1. ViewRootImpl中的事件队列是 链表``QueuedInputEvent`  维护了head和tail

## 3. 责任链处理：InputStage机制

拿到事件后，ViewRootImpl 并不立刻丢给 DecorView，而是让事件通过一系列 **InputStage**（输入阶段）过滤器： 

- **NativePreIme**：原生输入法预处理。
- **ViewPreIme**：View 层输入法预处理。
- **Ime**：交由输入法（IME）处理。
- **ViewPostImeStage**（关键点）：如果上面的阶段都没拦截，事件会进入这个阶段，这里才会真正执行 `mView.dispatchPointerEvent(event)`，从而开始分发给 **DecorView**。 

**流水线装配**

```

// Set up the input pipeline.
CharSequence counterSuffix = attrs.getTitle();
mSyntheticInputStage = new SyntheticInputStage();
InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage,
        "aq:native-post-ime:" + counterSuffix);
InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
InputStage imeStage = new ImeInputStage(earlyPostImeStage,
        "aq:ime:" + counterSuffix);
InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage,
        "aq:native-pre-ime:" + counterSuffix);

mFirstInputStage = nativePreImeStage;
mFirstPostImeInputStage = earlyPostImeStage;
```

## 4. 传递给Activity

尽管 `DecorView` 是 View 树的根，但它通常会将事件先交给 Activity： 

- **DecorView -> Activity：** `DecorView.dispatchTouchEvent` 会先回调其关联 Window 的 Callback（即 Activity）。
- **Activity 的处理：** `Activity.dispatchTouchEvent` 被触发。
- **Activity -> PhoneWindow -> DecorView：** 如果 Activity 没有消费，它会调用 `getWindow().superDispatchTouchEvent(event)`，事件绕了一圈再次回到 `DecorView`。 

## 5. 递归分发：`ViewGroup` 与 `View`

一旦事件回到 `DecorView`（它是一个特殊的 `FrameLayout`/`ViewGroup`），就进入了开发者熟悉的标准分发流程： 

- **`dispatchTouchEvent`**：由上至下（父到子）决定由谁分发。
- **`onInterceptTouchEvent`**：ViewGroup 决定是否拦截。
- **`onTouchEvent`**：由下至上（子到父）决定由谁消费。

# 6.ViewRootImpl 

Android的UI架构设计中，`ViewRootImpl`是很重要的一个设计

**UI架构**

- `ViewRootImpl`本身不是一个View，实现`ViewParent`接口，关联Window和根布局
- 事件分发入口
  - 屏幕事件通过epoll机制从nativePollOnce中


事件分发、View绘制等流程都是很重要的



