# 数据结构

> 数据结构是存储和组织数据的一种方式，以便对数据进行访问和修改。没有哪一种数据结构可以是用于所有的用途和目的，所以了解集中数据结构的长处和局限性相当重要。——《算法导论》

### 常见数据结构

> [`Runoob`菜鸟教程]((https://www.runoob.com/data-structures/data-structures-tutorial.html))
>
> [数据结构基础知识体系](https://pdai.tech/md/algorithm/alg-basic-overview.html)

- **数组(Array)：**内存连续，下标寻址快，增删操作复杂

- **链表（Linked List）：**链式存储，增删快，查询慢

- **散列表（Hash table）：**散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。

- **栈（Stack）：**后进先出 (`Last in first out, LIFO`) 

- **队列（Queue）：**先进先出(`First in first out, FIFO`)

- **树（Tree）: **非线性结构

  > 只有前序遍历和中序遍历是没有办法构建一个二叉树的

  - **二叉搜索树(`Binary Search Tree`)**

    性质：

    - 若任意节点的左子树不为空，则左子树上所有节点均小于根节点值
    - 若任意节点的右子树不为空，则右子树上所有节点均大于根节点值
    - 任意节点的左右子树也分别是二叉查找树
    - 没有键值相等的节点

    特点：二叉树的中序遍历为键值升序遍历

    **删除**

    > 节点的前驱: 是该节点的左子树中的最大节点。 节点的后继: 是该节点的右子树中的最小节点。

    - 被删节点有左右子树 => 前驱替代
    - 被删节点只有左子树或者右子树 => 孩子替代
    - 被删节点没有孩子 => 直接删除

    <img src="https://raw.githubusercontent.com/RabbitFeng/TyporaPic/main/images/alg-tree-10.png" alt="img" style="zoom:50%;" />

    ![img](https://raw.githubusercontent.com/RabbitFeng/TyporaPic/main/images/alg-tree-binary-search-1.svg)

    

  - **平衡二叉树(`Balanced Binary Tree, AVL`)**

  - **红黑树(R-B Tree)**

  - 哈夫曼树

  - 前缀树

    



- **树（Tree）：**树是典型的非线性结构，它是包括，2 个结点的有穷集合 K。
- **图（Graph）：**图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。
- **堆（Heap）：**堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。
- **散列表（Hash table）：**散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。

### 常用算法

数据结构研究的内容：就是如何按一定的逻辑结构，把数据组织起来，并选择适当的存储表示方法把逻辑结构组织好的数据存储到计算机的存储器里。算法研究的目的是为了更有效的处理数据，提高数据运算效率。数据的运算是定义在数据的逻辑结构上，但运算的具体实现要在存储结构上进行。一般有以下几种常用运算：

- **检索：**检索就是在数据结构里查找满足一定条件的节点。一般是给定一个某字段的值，找具有该字段值的节点。
- **插入：**往数据结构中增加新的节点。
- **删除：**把指定的结点从数据结构中去掉。
- **更新：**改变指定节点的一个或多个字段的值。
- **排序：**把节点按某种指定的顺序重新排列。例如递增或递减。

# 算法(`Algorithm`)

> 有关算法的描述：
>
> 算法就是定义良好的计算过程，取一个或一组值作为输入，产生一个或者一组值作为输出。或者说算法就是一系列的计算步骤，用来将输入数据转换成输出结果。算法也可以看作一个计算工具，用来解决一个具有良好规格描述的计算问题。
>
> 算法的意义
>
> 计算机计算时间和存储空间都是作为有限的资源，有限的资源必须要有效的利用。时间和空间上有效的算法有助于做到这一点。
>
> 不得不提到算法的效率。解决同一问题的各种不同算法的效率往往相差很大，这种效率上差距的影响往往比硬件和软件方面的差距来得大。
>
> 算法和其他技术的关系
>
> 即便很多在应用层面上对算法性没什么要求的应用，其实也相当依赖于算法。包括硬件的设计、用户界面的设计、网络技术、甚至代码的编译器解释器等等。算法是当代计算机中用到的大部分技术的核心。



## 算法正确性

循环不变式，用于帮助我们理解算法的正确性。对于循环不变时，必须证明它的三个性质

- **初始化**：在循环的第一轮迭代开始之前，应该是正确的
- **保持**：如果在循环的某一次迭代开始之前是正确的，那么在下一次迭代开始之前，也应该保持正确
- **终止**：当循环结束时，不变式给了一个有用的性质，有助于表明算法是正确的

当前两个性质成立，就能保证循环不变式在循环的每一轮迭代开始之前都是正确的。这里和推理和数学归纳法相似， 在数学归纳法中，如果要证明某一个性质成立，必须首先证明其基本情况和一个归纳步骤都是成立的。

第三项性质最重要，主要是用不变式来证明算法正确性的。此外，它和数学归纳法的常见用法不同：在归纳法中，归纳步骤是无穷地使用的，在这里，循环结束时，就终止“归纳”。



## 算法分析

对一个算法所需要的资源进行预测。内存、通信带宽或者计算机硬件等资源是我们主要关心的。但是通常来说，资源是指我们希望测度的计算时间。

> 在分析一个算法之前，要建立有关的技术模型。这里我们采用的是一种通用的单处理器、随机存取器(`random-access machine,RAM`)计算模型来作为实现技术。在`RAM`模型中，指令逐条执行，没有并发操作。依据现实中的计算机设计方式模型包含真是计算机中常见指令：算数指令(加减乘除、取余、取整指令)、数据移动指令(装入、存储、复制)和控制指令(条件和非条件转移、子程序调用和返回指令)，其中每条指令所需要的时间都是常量。没有试图对当代计算机常见的存储器层次，如高速缓存、虚拟内存等进行建模。
>
> 即便是这样，分析一个简单的算法也往往是比较困难的。所需要数学工具包含组合数学、概率论、代数，还要求能够识别出一个公式中最重要的部分。

一般来说，算法所需要的时间是输入规模同步增长的，因而常常将一个程序的运行时间表述为其输入规模的函数。那么需要对运行时间和输入规模更加仔细的定义

> ***输入规模：***和具体问题有关最自然的度量标准是输入元素的个数，如，待排序数组大小n。有时可能用两个数来描述输入更加合适。
>
> ***运行时间：***特定输入时所执行的基本操作数(步数)。

通常我们会假定，对于具有某一规模的所有输入是等可能的，但是实践中这一假设未必成立，有时可以采用随机化算法，让算法做出随机的选择，从而允许算法进行概率分析。

对于插入排序算法啊，简化得到的最坏运行时间可以描述为$an^2 + bn + c$,其中`a`,`b`,`c`是依赖于每条语句真实代价`ci`的常量。进一步抽象，即***运行时间的增长率(rate of growth)***或者***增长的量级(order of growth)***，这样只需要考虑公式中的最高次项，如$an^2$，忽略低阶项以及最高次项的参数，得到插入排序算法最坏时间代价是$Θ(n^2)$

算法渐进符号

- $Θ$ `Theta`，渐进精确界
- $O$  `Omicron`，渐进上界
- $Ω$ `Omega`，渐进下界
- `o` `Omicron`，非渐进精确上界
- $ω$ `Omega`，渐进下界



## 时间复杂度

通过`O(Omicron)`表示，时间复杂度公式：$T(n) = O(f(n))$

常见的时间复杂度量级

- 常数阶$O(1)$
- 对数阶$O(logN)$
- 线性阶$O(n)$
- 线性对数阶$O(nlogN)$
- 平方阶$O(n²)$
- 立方阶$O(n³)$
- K次方阶$O(n^k)$
- 指数阶$(2^n)$

> 这边我们考虑算法增长量级，忽略低阶次项和最高阶的常量



## 排序算法

> 在算法的设计上分为***增量(`incremental`)*** 方法和***分治法(`divide-and-conquer`)***
>
> - ***插入排序*** 使用的就是增量的方法，在排好子数组`A[1..j-1]`后，将元素`A[j]`插入，形成排序好的`A[1..j]`

### 1.冒泡排序(Bubble Sort)











###







